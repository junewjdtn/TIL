# TIL_Java_220518

---

###### 																														책 - 이것이 자바다 신용권의 Java 프로그래밍 정복 1 (p.2 ~ p.56)

---

### 1.1 프로그래밍 언어란?

- 컴퓨터가 이해할 수 있는 언어
- 0과 1로 이루어진 이진 코드

---

### 1.2 자바란?

#### 1.2.2 자바의 특징

- 객체 지향 언어이다.

  - 프로그램을 개발하는 기법으로 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법

    → 객체 지향 프로그래밍(OOP : Object Oriented Programming)

- 함수적 스타일 코딩을 지원

- 메모리를 자동으로 관리

- 멀티 스레드(Muit-Thread)를 쉽게 구현

- 동적 로딩(Dynamic Loading)을 지원

---

#### 1.2.3 자바 가상 기계(JVM)

- 운영체제는 자바 프로그램을 바로 실행할 수 없음

  → 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요한데 이것이 

  ​	자바 가상 기계(JVM : Java Virtual Machine)이다.

---

#### 1.4.2 프로그램 소스 분석

- 자바 실행 프로그램은 반드시 클래스(class)블록과 main() 메소드(method) 블록으로 구성되어야 함

- 메소드 블록은 단독으로 작성될 수 없고 항상 클래스 블록 내에서 작성되어야 함

  - 클래스 : 필드 또는 메소드를 포함하는 블록
    - 클래스의 이름은 개발자 마음대로 정할 수 있음
    - 소스 파일명과 대소문자가 일치해야 함

  - 메소드 : 어떤 일을 처리하는 실행문들을 모아 놓은 블록
    - 메소드의 이름은 개발자 마음대로 정할 수 있음
    - main()메소드 만큼은 다른 이름으로 바꾸면 안됨

---

### 1.5 주석과 실행문

#### 1.5.1 주석 사용하기

- 주석은 프로그램 실행과는 상관없이 코드에 설명을 붙인 것
- 가급적이면 설명이 필요한 코드에 주석을 달아 두는 것이 좋음
  - //		: //부터 라인 끝까지 주석으로 처리함 (행주석)
  - /* */   : / *와 */사이에 있는 모든 범위를 주석으로 처리 (범위 주석)

---

#### 1.5.2 실행문과 세미콜론(;)

- 실행문은 변수 선언, 값 저장, 메소드 호출에 해당하는 코드를 말함
- 실행문의 마지막에는 반드시 세미콜론(;)을 붙여서 실행문이 끝났음을 표시

---

### 2.1 변수

#### 2.1.1 변수란?

- 프로그램은 작업을 처리하는 과정에서 필요에 따라 데이터를 메모리에 저장하는데, 이때 변수를 사용함
- 변수(Variable)는 값을 저장할 수 있는 메모리의 공간을 의미
- 단 하나의 값만 저장할 수 있음 (한 가지 타입의 값만 저장)

---

#### 2.1.2 변수의 선언

- 변수 선언은 어떤 타입의 데이터를 저장할 것인지 그리고 변수 이름이 무엇인지를 결정

```Java
int age;
double value;
int x, y, z;
```

- 변수 이름은 메모리 주소에 붙여진 이름
- 프로그램은 변수 이름을 통해서 메모리 주소에 접근하고, 그곳에 값을 저장하거나 그곳에 있는 값을 읽음
- 자바 예약어로 사용할 수 없음

---

#### 2.1.3 변수의 사용

##### 변수값 저장

- 변수를 사용한다는 것은 변수에 값을 저장하고 읽는 행위

- 변수에 값을 저장할 때에는 대입 연산자(=)를 사용

  → 일반 수학에서는 =은 같다는 의미지만, 자바에서는 우측의 값을 좌측 변수에 저장한다는 의미

- 변수를 선언하고 처음 값을 저장할 경우 이러한 값을 초기값 이라 함

  → 변수에 초기값을 주는 행위를 변수의 초기화라고 함

``` java
int score; 		// 변수 선언
socre = 90;		// 값 저장
int socre1 = 90;
```

- 변수의 초기값은 코드에서 직접 입력하는 경우가 많은데, 소스 코드 내에서 직접 입력된 값을 리터럴(literal)이라 함

  → 사실 리터럴은 상수(constant)와 같은 의미이지만, 프로그램에서는 상수를 "값을 한 번 저장하면 변경할 수 없는 변수"로 정의 하기 때문에 이와 구분하기 위해 "리터럴"이라는 용어를 사용

##### | 정수 리터럴 |

- 소수점이 없는 정수 리터럴은 10진수로 간주
- 0으로 시작하는 리터럴은 8진수로 간주
- 0x, 0X로 시작하고 0~9 숫자나 A, B, C, D, E, F or a, b, c, d, e, f로 구성된 리터럴은 16진수로 간주
- 정수 리터럴을 저장할 수 있는 타입은 byte, char, short, int, long이 있음

##### | 실수 리터럴 |

- 소수점이 있는 리터럴은 10진수 실수로 간주
- 대문자 E, 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주
- 실수 리터럴을 저장할 수 있는 타입은 float, double이 있음

##### | 문자 리터럴 |

- 작은 따옴표(')로 묶은 텍스트는 하나의 문자 리터럴로 간주
- 역슬래쉬( \ )가 붙은 문자 리터럴은 이스케이프(escape)문자라고도 하는데 특수한 용도로 사용함
- 문자 리터럴은 저장할 수 있는 타입은 char 하나

##### | 문자열 리터럴 |

- 큰 따옴표 (")로 묶은 텍스트는 문자열 리터럴로 간주
- 문자열 리터럴 내부에서도 이스케이프 문자를 사용할 수 있음
- 문자열 리터럴을 저장할 수 있는 타입은 String 하나

##### | 논리 리터럴 |

- true와 false는 논리 리터럴로 간주
- 논리 리터럴을 저장할 수 있는 타입은 boolean 하나

##### | 변수값 읽기 |

- 변수는 초기화가 되어야 읽을 수가 있음 (초기화되지 않은 변수는 읽을 수가 없음)

``` java
int value;					//변수 value 선언 (초기화 안 됨)
int result = value + 10;	//변수 value 값을 읽고 10을 더한 결과값을 변수 result에 저장
```

- 변수 value가 선언 되었지만 초기화가 이루어 지지 않았기 때문에 사용할 수 없음 (다음과 같이 바꾸어 줘야함)

``` java
int value = 30;
int result = value + 10;
```

---

#### 2.1.4 변수의 사용 범위

- 변수는 중괄호 { } 블록 내에서 선언되고 사용됨

- 중괄호 블록을 사용하는 곳은 클래스, 생성자, 메소드

- 메소드 블록 내에서 선언된 변수를 로컬 변수(local variable)

  → 메소드 실행이 끝나면 메모리에서 자동으로 없어짐

- 변수는 선언된 블록 내에서만 사용 가능

- 조건문에 해당하는 if() {}, 반복문에 해당하는 for() {}, while() {} 등이 중괄호를 가질 수 있으며 if, for, while을 제어문이라고 하는데 제어문 블록에서 선언된 변수는 해당 제어문 블록 내에서만 사용 가능하고 블록 밖에서는 사용할 수 없음

---

### 2.2 데이터 타입

- 모든 변수에는 타입이 있으며, 타입에 따라 저장할 수 있는 값의 종류와 범위가 달라짐
- 변수를 선언할 때 주어진 타입은 변수를 사용하는 도중 변경할 수 없음

---

#### 2.2.1 기본(원시:primitive)타입

- 기본 타입이란 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말함
  - 정수 타입 : byte, char, short, int, long
  - 실수 타입 : float, double
  - 논리 타입 : boolean
- 메모리에는 0과 1을 저장하는 최소 기억 단위인 비트(bit)가 있음
- 8개의 비트를 묶어서 바이트(byte)라고 함
- 기본 타입은 정해진 메모리 사용 크기 (바이트 크기)로 값을 저장하는데 바이트 크기가 클수록 표현하는 값의 범위가 큼

---

#### 2.2.2 정수 타입(byte, char, short, int, long)

| 정수 타입 | byte | char | short | int  | long |
| :-------: | :--: | :--: | :---: | :--: | :--: |
| 바이트 수 |  1   |  2   |   2   |  4   |  8   |

- 자바는 기본적으로 정수 연산을 int 타입으로 수행
- 저장하려는 값이 정수 리터럴이라면 특별한 이유가 없는 한 int 타입 변수에 저장하는 것이 좋음

##### | byte 타입 |

- byte 타입은 색상 정보 및 파일 또는 이미지 등의 이진(바이너리) 데이터를 처리할 때 주로 사용됨
- 저장할 수 있는 값의 범위를 초과해서 값이 저장될 경우 엉터리 값이 변수에 저장되는데 이것을 쓰레기값이라 함

##### | char 타입 |

- 자바는 모든 문자를 유니코드(Unicode)로 처리함

  → 유니코드 : 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약

- 프로그램 코드에서 char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면 됨

``` java
char c = 'A';
int uniCode = c;
```

- String은 기본 타입이 아님
- String은 클래스 타입이고 String 변수는 참조 변수이다.
- 문자열을 String 변수에 대입하면 문자열이 변수에 직접 저장되는 것이 아닌 String 객체가 생성되고, String 변수는 String 객체의 번지를 참조하는 것이다. (추후 다시 배울 것)

##### | short 타입 |

- short 타입은 2byte(16bit)로 표현되는 정수 값을 저장할 수 있는 데이터 타입

##### | int 타입 |

- 4byte(32bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입
- int 타입은 자바에서 정수 연산을 하기 위한 기본 타입

##### | long 타입 |

- 8byte(64bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입

---

#### 2.2.3 실수 타입(float, double)

- 실수 타입은 소수점이 있는 실수 데이터를 저장할 수 있는 타입으로, 메모리 사용 크기에 따라 float과 double이 있음

| 실수 타입 | float | double |
| :-------: | :---: | :----: |
| 바이트 수 |   4   |   8    |

- float과 double의 메모리 사용 크기는 각각 int와 long의 크기와 같지만, 정수 타입과는 다른 저장 방식 때문에 정수 타입보다 훨씬 더 큰 범위의 값을 저장할 수 있음
- 실수는 정수와 달리 부동 소수점(floation-point) 방식으로 저장 됨
- 자바는 실수 리터럴의 기본 타입을 double로 간주

----

#### 2.2.4 논리 타입(boolean)

- 1byte(8bit)로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입
- 두 가지 상태값을 저장할 필요성이 있을 경우 사용
- 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용

---

### 2.3 타입 변환

- 타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 것을 말함
  - 자동(묵시적) 타입 변환
  - 강제(명시적) 타입 변환

---

#### 2.3.1 자동 타입 변환

- 자동 타입 변환(Promotion)은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말함
- 자동 타입 변환은 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생함
- 변환 이전의 값은 변환 이후에도 손실 없이 그대로 보존됨
- char 타입의 경우 int 타입으로 자동 변환되면 유니코드 값이 int 타입에 저장
- 음수가 저장될 수 있는 byte 타입을 char 타입으로 자동 변환시킬 수 없음

---

#### 2.3.2 강제 타입 변환

- 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없음
- 강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 것을 강제 타입 변환(캐스팅 : casting)이라고 함
- 강제 타입 변환은 캐스팅 연산자 ()를 사용
- 사용자로부터 입력받은 값을 변환할 때 값의 손실이 발생하면 안됨
- 어떤 정수값과 실수값을 다른 타입으로 변환하고자 할 때는 변환될 타입의 최소값과 최대값을 벗어나는지 반드시 검사하고 만약 벗어난다면 타입 변환을 하지 말아야 함
